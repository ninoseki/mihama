import io
import os
import tempfile
import zipfile
from collections.abc import Generator
from pathlib import Path

import httpx
from git import Repo
from loguru import logger
from pydantic import ValidationError

from mihama import schemas, settings


class Bucket:
    def __init__(
        self,
        ecosystem: str,
        base_url: str = settings.OSV_BUCKET_BASE_URL,
        timeout: int = settings.OSV_BUCKET_TIMEOUT,
    ):
        self.ecosystem = ecosystem
        self.base_url = base_url
        self.timeout = timeout

    def get(self) -> Generator[tuple[str, bytes], None, None]:
        with httpx.Client(base_url=self.base_url, timeout=self.timeout) as client:
            res = client.get(f"/{self.ecosystem}/all.zip", timeout=self.timeout)
            res.raise_for_status()

        with zipfile.ZipFile(io.BytesIO(res.content)) as zip:
            for name in zip.namelist():
                yield name, zip.read(name)


class VulnerabilityFactory:
    @staticmethod
    def by_ecosystem(
        ecosystem: str,
        *,
        base_url: str = settings.OSV_BUCKET_BASE_URL,
        timeout: int = settings.OSV_BUCKET_TIMEOUT,
    ) -> list[schemas.Vulnerability]:
        if ecosystem not in settings.OSV_ECOSYSTEMS:
            raise ValueError(f"{ecosystem} is not supported")

        bucket = Bucket(ecosystem, base_url=base_url, timeout=timeout)
        vulns: list[schemas.Vulnerability | None] = [
            VulnerabilityFactory.model_validate_json(raw=raw, filename=filename)
            for filename, raw in bucket.get()
        ]
        return [v for v in vulns if v is not None]

    @staticmethod
    def model_validate_json(
        *, raw: bytes | str, filename: str, raise_validation_error: bool = False
    ) -> schemas.Vulnerability | None:
        try:
            return schemas.Vulnerability.model_validate_json(raw)
        except ValidationError as e:
            logger.error(f"{filename} does not follow the OSV schema: {e}")

            import os

            basename = os.path.basename(filename)
            with open(f"/tmp/osv/{basename}", "wb") as f:
                if isinstance(raw, str):
                    f.write(raw.encode())
                else:
                    f.write(raw)

            if raise_validation_error:
                raise e

        return None

    @staticmethod
    def from_path(
        path: Path | str,
        *,
        raise_validation_error: bool = False,
    ) -> schemas.Vulnerability | None:
        path = Path(str(path))
        return VulnerabilityFactory.model_validate_json(
            raw=path.read_bytes(),
            filename=path.name,
            raise_validation_error=raise_validation_error,
        )

    @staticmethod
    def from_directory(
        directory: str, *, raise_validation_error: bool = False, pattern: str = "*.json"
    ) -> list[schemas.Vulnerability]:
        if not os.path.isdir(directory):
            raise ValueError(f"{directory} is not a directory")

        paths = [p for p in Path(directory).glob(pattern) if p.is_file()]
        vulns: list[schemas.Vulnerability | None] = [
            VulnerabilityFactory.from_path(
                p,
                raise_validation_error=raise_validation_error,
            )
            for p in paths
        ]
        return [v for v in vulns if v is not None]

    @staticmethod
    def from_repo_url(repo_url: str, *, raise_validation_error: bool = False):
        with tempfile.TemporaryDirectory() as dir:
            Repo.clone_from(repo_url, dir)
            return VulnerabilityFactory.from_directory(
                dir,
                raise_validation_error=raise_validation_error,
                pattern="**/*.json",
            )
