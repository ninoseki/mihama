import io
import os
import tempfile
import zipfile
from collections.abc import Generator
from pathlib import Path

import requests
from git import Repo  # type: ignore
from loguru import logger
from pydantic import ValidationError

from mihama import models
from mihama.core import settings


class Bucket:
    def __init__(
        self,
        ecosystem: str,
        base_url: str = settings.OSV_BUCKET_BASE_URL,
        timeout: int = settings.OSV_BUCKET_TIMEOUT,
    ):
        self.ecosystem = ecosystem
        self.base_url = base_url
        self.timeout = timeout

    def _url_for(self, path: str) -> str:
        return self.base_url + path

    def get(self) -> Generator[tuple[str, bytes], None, None]:
        url = self._url_for(f"/{self.ecosystem}/all.zip")
        res = requests.get(url, timeout=self.timeout)
        res.raise_for_status()

        with zipfile.ZipFile(io.BytesIO(res.content)) as zip:
            for name in zip.namelist():
                yield name, zip.read(name)


class VulnerabilityFactory:
    @staticmethod
    def by_ecosystem(
        ecosystem: str,
        *,
        base_url: str = settings.OSV_BUCKET_BASE_URL,
        timeout: int = settings.OSV_BUCKET_TIMEOUT,
    ) -> list[models.Vulnerability]:
        if ecosystem not in settings.OSV_ECOSYSTEMS:
            raise ValueError(f"{ecosystem} is not supported")

        bucket = Bucket(ecosystem, base_url=base_url, timeout=timeout)
        vulns: list[models.Vulnerability | None] = [
            VulnerabilityFactory.parse_raw(raw=raw, filename=filename)
            for filename, raw in bucket.get()
        ]
        return [v for v in vulns if v is not None]

    @staticmethod
    def parse_raw(
        *, raw: bytes | str, filename: str, raise_validation_error: bool = False
    ) -> models.Vulnerability | None:
        try:
            return models.Vulnerability.parse_raw(raw)
        except ValidationError as e:
            logger.error(f"{filename} does not follow the OSV schema: {e}")
            if raise_validation_error:
                raise e

        return None

    @staticmethod
    def from_directory(
        directory: str, *, raise_validation_error: bool = False, pattern: str = "*.json"
    ) -> list[models.Vulnerability]:
        if not os.path.isdir(directory):
            raise ValueError(f"{directory} is not a directory")

        paths = [p for p in Path(directory).glob(pattern) if p.is_file()]
        vulns: list[models.Vulnerability | None] = [
            VulnerabilityFactory.parse_raw(
                raw=p.read_bytes(),
                filename=p.name,
                raise_validation_error=raise_validation_error,
            )
            for p in paths
        ]
        return [v for v in vulns if v is not None]

    @staticmethod
    def from_repo_url(repo_url: str, *, raise_validation_error: bool = False):
        with tempfile.TemporaryDirectory() as dir:
            Repo.clone_from(repo_url, dir)
            return VulnerabilityFactory.from_directory(
                dir,
                raise_validation_error=raise_validation_error,
                pattern="**/*.json",
            )
