import contextlib
from types import MappingProxyType
from typing import cast

from elasticsearch import AsyncElasticsearch
from elasticsearch.helpers import async_bulk
from elasticsearch_dsl import AsyncMultiSearch, AsyncSearch, Q
from elasticsearch_dsl.query import Query
from elasticsearch_dsl.response import Hit, HitMeta, Response

from mihama import schemas, settings
from mihama.query import normalize_query

DEFAULT_SORT = MappingProxyType({"modified": {"order": "desc"}})


def hits_to_vulns(hits: list[Hit]) -> list[schemas.Vulnerability]:
    vulns: list[schemas.Vulnerability] = []
    for hit in hits:
        hit = cast(Hit, hit)
        meta = cast(HitMeta, hit.meta)

        data = hit.to_dict()
        with contextlib.suppress(Exception):
            data["sort"] = meta.to_dict()["sort"]

        vulns.append(schemas.Vulnerability.model_validate(data))

    return vulns


def build_package_query(package: schemas.QueryPackage | schemas.SearchPackage) -> Query:
    must: list[Query] = []

    if package.ecosystem is not None:
        must.append(Q("term", affected__package__ecosystem__keyword=package.ecosystem))

    if package.name is not None:
        must.append(Q("term", affected__package__name__keyword=package.name))

    if package.purl is not None:
        must.append(Q("term", affected__package__purl__keyword=package.purl))

    return Q("bool", must=must)


def build_search_query(
    ecosystem: str | None = None, id_or_package_name: str | None = None
) -> Query:
    must: list[Query] = []
    if ecosystem is not None:
        must.append(Q("term", affected__package__ecosystem__keyword=ecosystem))

    should: list[Query] = []
    if id_or_package_name is not None:
        should.append(Q("term", affected__package__name__keyword=id_or_package_name))
        should.append(Q("term", id__keyword=id_or_package_name))

    if len(should) > 0:
        must.append(Q("bool", should=should))

    return Q("bool", must=must)


def filter_vulns_by_query(vulns: list[schemas.Vulnerability], query: schemas.Query):
    if query.package is None or query.version is None:
        return vulns

    return [
        v
        for v in vulns
        if v.is_affected_package_version(package=query.package, version=query.version)
    ]


class CRUDVulnerability:
    async def get(
        self,
        es: AsyncElasticsearch,
        id: str,
        *,
        index: str = settings.ES_INDEX,
    ) -> schemas.Vulnerability:
        got = await es.get(index=index, id=id)
        return schemas.Vulnerability.model_validate(got.raw["_source"])

    async def index(
        self,
        es: AsyncElasticsearch,
        vuln: schemas.Vulnerability,
        *,
        index: str = settings.ES_INDEX,
        refresh: bool = False,
    ):
        return await es.index(
            index=index,
            document=vuln.model_dump(mode="json"),
            id=vuln.id,
            refresh=refresh,
        )

    async def index_if_not_exists(
        self,
        es: AsyncElasticsearch,
        vuln: schemas.Vulnerability,
        *,
        index: str = settings.ES_INDEX,
        refresh: bool = False,
    ):
        if await self.exists(es, vuln.id):
            return None

        return await self.index(es, vuln=vuln, index=index, refresh=refresh)

    async def exists(
        self,
        es: AsyncElasticsearch,
        id: str,
        *,
        index: str = settings.ES_INDEX,
    ) -> bool:
        return await es.exists(index=index, id=id)  # type: ignore

    async def bulk_index(
        self,
        es: AsyncElasticsearch,
        vulns: list[schemas.Vulnerability],
        *,
        index: str = settings.ES_INDEX,
        refresh: bool = False,
    ):
        async def actions():
            for vuln in vulns:
                yield {
                    "_id": vuln.id,
                    "_index": index,
                    "_source": vuln.model_dump(mode="json"),
                }

        return await async_bulk(es, actions(), refresh=refresh)

    async def delete(
        self, es: AsyncElasticsearch, id: str, *, index: str = settings.ES_INDEX
    ):
        return await es.delete(index=index, id=id)

    async def search(
        self,
        es: AsyncElasticsearch,
        *,
        ecosystem: str | None = None,
        id_or_package_name: str | None = None,
        search_after: list[int] | None = None,
        size: int = 100,
        index: str = settings.ES_INDEX,
    ) -> list[schemas.Vulnerability]:
        q = build_search_query(ecosystem, id_or_package_name)

        s: AsyncSearch = (
            AsyncSearch(using=es, index=index)
            .query(q)
            .extra(size=size)
            .sort(dict(DEFAULT_SORT))
        )
        if search_after is not None:
            s = s.extra(search_after=search_after)

        response = await s.execute()
        return hits_to_vulns(response.hits)  # type: ignore

    async def count(
        self,
        es: AsyncElasticsearch,
        ecosystem: str | None = None,
        id_or_package_name: str | None = None,
        *,
        index: str = settings.ES_INDEX,
    ) -> int:
        q = build_search_query(ecosystem, id_or_package_name)
        s: AsyncSearch = AsyncSearch(using=es, index=index).query(q)
        return await s.count()  # type: ignore

    async def search_by_package(
        self,
        es: AsyncElasticsearch,
        package: schemas.QueryPackage | schemas.SearchPackage,
        *,
        size: int = 1000,
        index: str = settings.ES_INDEX,
        search_after: list[int] | None = None,
    ) -> list[schemas.Vulnerability]:
        q = build_package_query(package)

        s: AsyncSearch = (
            AsyncSearch(using=es, index=index)
            .query(q)
            .extra(size=size)
            .sort(dict(DEFAULT_SORT))
        )
        if search_after is not None:
            s = s.extra(search_after=search_after)

        response = await s.execute()
        return hits_to_vulns(response.hits)  # type: ignore

    async def search_by_query(
        self,
        es: AsyncElasticsearch,
        query: schemas.Query,
        *,
        index: str = settings.ES_INDEX,
    ) -> list[schemas.Vulnerability]:
        normalized = normalize_query(query)
        if normalized.package is None:
            return []

        vulns = await self.search_by_package(es, normalized.package, index=index)
        return filter_vulns_by_query(vulns, query)

    async def count_by_package(
        self,
        es: AsyncElasticsearch,
        package: schemas.QueryPackage | schemas.SearchPackage,
        *,
        index: str = settings.ES_INDEX,
    ) -> int:
        q = build_package_query(package)
        s: AsyncSearch = AsyncSearch(using=es, index=index).query(q)
        return await s.count()  # type: ignore

    async def query(
        self, es: AsyncElasticsearch, q: schemas.Query
    ) -> schemas.Vulnerabilities:
        vulns = await self.search_by_query(es, q)
        return schemas.Vulnerabilities(vulns=vulns)

    async def querybatch(
        self,
        es: AsyncElasticsearch,
        queries: schemas.BatchQuery,
        *,
        index: str = settings.ES_INDEX,
        size: int = 1000,
    ) -> schemas.BatchResponse:
        ms = AsyncMultiSearch(using=es, index=index)
        searched_queries: list[schemas.Query] = []
        for query in queries:
            normalized = normalize_query(query)
            if normalized.package is None:
                continue

            s: AsyncSearch = (
                AsyncSearch(using=es, index=index)
                .query(build_package_query(normalized.package))
                .extra(size=size)
                .sort(dict(DEFAULT_SORT))
            )
            if query.search_after is not None:
                s = s.extra(search_after=query.search_after)

            ms = ms.add(s)
            searched_queries.append(normalized)

        if len(searched_queries) == 0:
            return schemas.BatchResponse(results=[])

        responses: list[Response] = await ms.execute()
        queries_responses = zip(searched_queries, responses, strict=True)

        results: list[schemas.Vulnerabilities] = []
        for query, response in queries_responses:
            vulns = hits_to_vulns(response.hits)  # type: ignore
            results.append(
                schemas.Vulnerabilities(vulns=filter_vulns_by_query(vulns, query))
            )

        return schemas.BatchResponse(results=[r.simplify() for r in results])


vulnerability = CRUDVulnerability()
